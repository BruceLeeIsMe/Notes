# Java中的数据类型

## 基本数据类型

又名：原生类型、内置类型。

1. 整型 **byte** **short**(2 byte) **int**(4 byte) **long**(8 byte)
2. 浮点型 **float**(4 byte) **double**(8 byte)
3. 字符型 **char**(2 byte) Java使用Unicode编码，可以存储汉字
4. 布尔型 **boolean**(1 byte) 理论占1 bit 实际占用1 byte



默认类型：

​	int为整型的默认类型

​	double为浮点型的默认类型



如何输入基本数据类型：

整型：

```java
	byte b=12;
	short s=12;
	long l=12L;
```
浮点型：

```java
	float f=1.0f;
	double d=1.0d;：
```


### 类型转换相关：

​	byte、short在数学运算的时候，会自动转化为int类型进行计算。

#### 自动类型转换：

**情境一：小类型与大类型运算时，自动转化为大类型**

byte b=1;

b=b+1;//编译不通过，需要强制类型转换

b+=1;//编译通过

为什么呢？底层原理：

​	通过反编译得知，字节码文件内容如下：

![avap](H:\GitRepository\Notes\java\img\javap.png)

在add操作结束之后，使用了i2b命令（int to byte），**自动**对结果类型进行了**强制类型转换**。

**情境二：小类型赋值给大类型，自动转化为大类型**

byte b=1;

int i=b;

#### 强制类型转换

小类型转换为大类型时，强制类型转换，截取低位（保留低位）。

```java
byte b=byte(1); // 此处保留低八位

// b值为1
```

**注意：**

强制转换为小类型时，大类型的 **数据位** 可能会变成小类型的  **符号位**！

```java
byte b=byte(129);// 此处保留低八位

// b值为-127
```

129:	补码为：0000 0000,0000 0000,0000 0000,1000 0001

截取byte大小的低位: 1000 0001(补码)



疑问？补码的符号位与原码符号位是一样的吗？？



如果是一样的话，补码为1000 0001，是负数，则转为原码，取反+1：1111 1111即：-127

----

### i++与++i问题：

int i=0;

int j=i++;

结果：i=1;j=0;

![223](H:\GitRepository\Notes\java\img\123.png)

i++完成后，i并没有进入操作数栈，于是之前存入栈顶的 0 弹出到 j

----

i=0;

j=++j;

结果：i=1;j=1;

![223](H:\GitRepository\Notes\java\img\223.png)

完成++j后，将 j 再载入到操作数栈，再将其存储弹出 j





但是如何记忆i++与++i的区别呢。总不能每次都去反编译读字节码吧！

？？？？

**总结：**

如：

```java
int i=0;

i++;//++i;
```

​	理解为，i++与++i其实都有返回值。

​		i++先自增，再返回自增前的值。

​		++i先自增，再返回自增后的值。









## 引用数据类型

1. 类
2. 接口
3. 数组

### 类型转换

1. 父类型转子类型
2. 子类型转父类型

类型转换之后，引用与实例字段，静态字段方法，之间的关系





