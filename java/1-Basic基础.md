# Java中的数据类型

## 基本数据类型

又名：原生类型、内置类型。

1. 整型 **byte** **short**(2 byte) **int**(4 byte) **long**(8 byte)
2. 浮点型 **float**(4 byte) **double**(8 byte)
3. 字符型 **char**(2 byte) Java使用Unicode编码，可以存储汉字
4. 布尔型 **boolean**(1 byte) 理论占1 bit 实际占用1 byte



默认类型：

​	int为整型的默认类型

​	double为浮点型的默认类型



如何输入基本数据类型：

整型：

```java
	byte b=12;
	short s=12;
	long l=12L;
```
浮点型：

```java
	float f=1.0f;
	double d=1.0d;：
```


### 类型转换相关：

​	byte、short在数学运算的时候，会自动转化为int类型进行计算。

#### 自动类型转换：

**情境一：小类型与大类型运算时，自动转化为大类型**

byte b=1;

b=b+1;//编译不通过，需要强制类型转换

b+=1;//编译通过

为什么呢？底层原理：

​	通过反编译得知，字节码文件内容如下：

![avap](H:\GitRepository\Notes\java\img\javap.png)

在add操作结束之后，使用了i2b命令（int to byte），**自动**对结果类型进行了**强制类型转换**。

**情境二：小类型赋值给大类型，自动转化为大类型**

byte b=1;

int i=b;

**情境三：复合运算符的自动转换**

```java
int a=1;

long b=2;

a+=b; // 隐含了 两次 类型转换，实际为 a=(int)((long)a+b)
	  // 一次为 运算时自动转换，另一次则为复合运算符进行的类型转换。
```

此时突然回忆起一个小知识点：两个相同类型的数运算时，那么运算结果类型不变，如果运算结果超出范围，则会造成精度丢失。

比如：

```java
int a=3;

double c = a/2;		// 错误，精度丢失

result: c=1;

===============================

double c = a/2.0;	// 正确

result: c=1.5;

===============================

int a=2147483647;
int c=a*2;			// 错误，精度丢失
System.out.println(c);// result: -2

===============================

long c=a*2L;			// 正确
System.out.println(c);// result: 4294967294

===============================
```

回到正题：

符合运算符用于简化书写,同时也有自动类型转换的作用。



**符合运算符们：**

`+=`：加法赋值

`-=`：

`*=`：

`/=`

`%=`

`>>=`：右移赋值

`<<=`：左移赋值

`&=`： 位与赋值

`|=`：位或赋值

`^=`：异或赋值



#### 强制类型转换

小类型转换为大类型时，强制类型转换，截取低位（保留低位）。

```java
byte b=byte(1); // 此处保留低八位

// b值为1
```

**注意：**

强制转换为小类型时，大类型的 **数据位** 可能会变成小类型的  **符号位**！

```java
byte b=byte(129);// 此处保留低八位

// b值为-127
```

129:	补码为：0000 0000,0000 0000,0000 0000,1000 0001

截取byte大小的低位: 1000 0001(补码)



疑问？补码的符号位与原码符号位是一样的吗？？

​	除`-128`以外，他们符号位都是一样的！



所以，负数 补码转原码，1000 0001取反+1 ：1111 1111即：-127

----

### i++与++i问题：

int i=0;

int j=i++;

结果：i=1;j=0;

![223](H:\GitRepository\Notes\java\img\123.png)

i++完成后，i并没有进入操作数栈，于是之前存入栈顶的 0 弹出到 j

----

i=0;

j=++j;

结果：i=1;j=1;

![223](H:\GitRepository\Notes\java\img\223.png)

完成++j后，将 j 再载入到操作数栈，再将其存储弹出 j





但是如何记忆i++与++i的区别呢。总不能每次都去反编译读字节码吧！

？？？？

**总结：**

如：

```java
int i=0;

i++;//++i;
```

​	理解为，i++与++i其实都有返回值。

​		i++先自增，再返回自增前的值。

​		++i先自增，再返回自增后的值。









## 引用数据类型

1. 类
2. 接口
3. 数组

### 类型转换

1. 父类型转子类型
2. 子类型转父类型
3. 

**个人理解总结：**

是否能强制转换成功，主要取决于此时堆中的实例对象是父类还是子类，而与引用类型无关。

堆中的是子对象则其引用可以随意向上转型为父对象引用，如果为父类型对象，则无法转为子类型引用。

```java
Fu f=(Fu)new Zi();	// 引用 向上转型成功
Zi z=(Zi)f;			// 引用 向下转型成功
```

```java
Fu f=new Fu();
Zi f=(Zi) f;	// 引用 向下转型失败，因为f引用指向的是父类实例对象，引用无法向下转型。
```

**复习继承相关知识：**

1. 父类实例变量会随继承到子类，如果子父类变量重名，那么父类变量被隐藏。
2. 父类实例方法会随继承到子类，如果子父类方法重名，那么父类方法被重写(overide)。
3. 静态方法以及静态字段，这是属于类的元素，不会在extends与implements中遗传到子类。



```java
class Fu{
	public static int staticVar=1;
	int instVar=2;
	public void showName(){
		System.out.println("this is Fu");		
	}
}
class Zi extends Fu{
	public static int staticVar=2;
	int instVar=1;
	public void showName(){
		System.out.println("this is Zi");
	}
    public void ziFun(){
        System.out.println("this is 子类 fun");
    }
    
    public static void main(String args[]){
        Fu f=(Fu)new Zi();	// 向上转型
        Zi z=(Zi)f;			// 向下转型
        /* 静态方法与字段 start */
        
        System.out.println(f.staticVar);// 为f引用所属类的静态字段，即1
        System.out.println(z.staticVar);// 为z引用所属类的静态字段，即2
        // ali编码规范中，说到不要用引用去访问静态字段，无端增加编译器负担，此处学习需要。
        
        /* 静态方法与字段 end */
        
        /*------------分割线---------------*/
        
        /* 实例变量以及方法 start */
        
        System.out.println(f.instVar);
        System.out.println(z.instVar);
        // 引用f,z 都是指向运行时堆中的同一个对象，所以两次输出都为上面实例化的Zi类的实例变量。
        // 当然执行的方法也是对应其实例化对象的方法
        
        // 父类引用调用 子类特有方法，编译失败
        f.ziFun();// 因为在编译时间，编译器通过符号引用f，只能找到符号引用f（ 即Fu）的方
        		  // 法，父类引用没有子类方法，所以报错
        
        /* 实例变量以及方法 end */
    }
}

```



# OOP特性

**object oriented programming：**



**四大特性：**



## 抽象

## 封装

## 继承

**java继承与实现：**

extends继承：

implements实现：

## 多态

1. 重写
2. 重载
3. 动态绑定



# 关键字：

## final

- 可以修饰类，函数，变量。

- 被final修饰的类不可以被继承。为了避免被继承，被子类复写功能。

- 被final修饰的方法不可以被复写。

- 被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，有可以修饰局部变量。

- 当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字。方便于阅读。

  而这个值不需要改变，所以加上final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成。单词间通过_连接。

- 内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。

## abstract

作用：
当多个类中出现相同功能，但是功能主体不同，
这是可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主体。
抽象类的特点：

​	抽象方法一定在抽象类中

​	抽象类与抽象方法一定由abstract修饰

​	抽象函数没有方法体，只有函数原型

​	抽象类不可以生成对象

​	如果子类只覆盖了抽象类中的部分抽象函数，那么该子类也是抽象函数，无法生成对象

**注意：**

特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。
抽象类也是类，所以也有默认的构造函数

- abstract 关键字，和哪些关键字不能共存：
- 不能和final一起出现，如果方法都不能覆盖了，类不能被继承了，那还要abstract来干嘛
- private，被private修饰了的方法无法被子类继承，所以也无法覆盖抽象方法
  如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。
  可是抽象方法运行没意义。（这点是摘抄的话，自己没怎么理解）

## interface

作用，提高程序扩展性，这东西有点好用的啊，虽然暂时没用到 哈哈哈哈
	   这个和多态组合在一起 简直强无敌，也就是多态和继承组合在一起 有点吊

举例：给电脑主板预留插槽 见多态
接口中的所有成员都是public的
可以理解为是一个由abstract public 修饰的抽象类

1. 接口中常见定义：变量，抽象方法

2.	接口中的成员都有固定的修饰符：
	
	a)	常量：public static final
b)	方法：public abstract

	疑问：Iterator接口中，有三个可调用的非抽象方法，这不是和概念冲突了吗，查阅了资料，原来Iterator中有一个内部类实现了这三个方法
	并且Iterator的实例对象不是通过构造函数获得的，而是通过集合的方法获取的迭代器

接口：是不可以创建对象的，因为有抽象方法。

需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化。
否则子类是一个抽象类。
接口可以被类多实现，也是对多继承不支持的转换形式。java支持多实现。

# 内部类



作用：当描述事物时，事物的内部还有事物，该事物用内部类来描述。
因为内部事务在使用外部事物的内容。
	优点：用于描述事物内部，对外界信息隐藏，简化代码
缺点：
内部类定义格式：
1.	定义在类中：
因为定义在类中，所以内部类作为类中的成员，所以可以被成员修饰符修饰，static private等修饰。
内部类可以 访问外部类的成员，是因为内部类中持有了一个外部类的引用，
格式:外部类名.this
如果外部类需要使用内部类，则需要生成内部类对象，
	
**注意：**
a)如果内部类中有静态方法，那么该类一定也是静态的。
因为要不建立对象访问到内部类的静态函数，所以要加载外部类的静态成员（内部类），因为加载了内部类（静态成员），所以也会加载该类的静态函数

b) 如果内部类被static修饰了，那就具备了static的特性。在外部其他类中，
可以直接访问static内部类的静态成员Outer(外部类类名).Inner(内部类类名).function();并且此时该类不可以在外部生成对象。

	c) 当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。
	可以直接建立内部类对象。
	格式
	外部类名.内部类名  变量名 = 外部类对象.内部类对象;
	Outer.Inner in = new Outer().new Inner();
	
2. 定义在局部代码块中
   a)	定义在局部代码中，可以直接访问外部类中的成员，因为还持有外部类中的引用。

   

   b)	但是不可以访问局部代码的一般局部变量，如果要访问局部变量，则该变量必须被final修饰。 

   

3. 匿名内部类
   匿名内部类必须要有父类，或者父接口（也就是类），自己没定义父类也不怕，java中所有类都是object的子类
   格式：

   ```
   new 父类名称(){
   	子类方法以及子类覆盖父类方法(){}
   }.子类方法();
   ```

   使用匿名内部类，调用对象中的方法只可以调用一次，如果想要调用多次，那每次都需要生成一个匿名对象

   

   使用匿名内部类，调用对象中的方法只可以调用一次，如果想要调用多次，那每次都需要生成一个匿名对象

# 可变参数

阿里编码规范不推荐使用 可变参数

通过数组实现，说白了，也就是个数组。

```
//利用可变参数，对传入的形参求和。 
int sum(int …param){
	int sum=0;
	for(int i=0;i<param.length;i++){
		sum+=param[i];
	}
}
```

# 对象初始化：

对象初始化：
举例说明：Person p=new Person(); 这句话到底执行了些什么（方法还未知何时进入内存，可能在属性进入内存之前？毕竟方法是要操作内存的 静态属性和方法可能会在对象生成之前进入内存，这些都是个人推断，还没有见到可靠文献描述）

1. 因为new用到了Person类，所以会先去找person类的class文件并加载到内存中

2. 将类加载到内存中，会先调用静态代码块给类（是类不是对象，因为static修饰的事

3. 类的属性,不是对象的属性）初始化 因为静态代码块优先于对象存在

4. 在堆内存中开辟空间，分配内存地址

5. 在堆内存中建立对象特有属性，并进行默认初始化（int a=10; 这种初始化）

6. 对对象进行构造代码块初始化

7. 对对象进行对应构造函数初始化

8. 将分配的地址 赋值给引用p

   

**父类情况的对象初始化顺序：**

1. 父类静态成员以及静态代码块初始化，按照代码中出现的顺序执行
2. 子类静态成员以及静态代码块初始化，按照代码中出现的顺序执行
3. 父类构造代码块执行，进行初始化，按照代码中出现的顺序执行
4. 子类构造代码块执行，进行初始化
5. 父类构造函数
6. 子类构造函数

## 构造函数：

没有返回值类型 与类名相同，默认构造函数权限修饰符 跟随 类的权限
		如果自己写了任意构造函数（即使函数体为空），也会覆盖默认构造函数即，系统默认的无参构造函数会失效，所以需要自定义一个无参的构造函数。

**构造函数可以设置为 私有，这样就可以无法生成对象**

带继承的构造函数：

子类必须在构造函数里调用父类的构造函数， 即使我们不显示调用，系统也会隐式调用（即super()；）
当然也可能存在这种情况，子类构造函数1中调用了this（参数表2） 那么这样其实调用了参数表2对应的构造函数，该构造函数中必定调用了父类构造函数。
所以，无论如何，生成子类对象时，百分之百会调用父类的构造函数（并且加载父类class文件，以及完成父类的静态代码块初始化，构造代码块初始化，构造函数初始化）

如果子类的构造函数有参数表，则必须在子类构造函数中显示调用super并传入参数。如果父类中有多个构造函数，且没有显示调用的情况，则默认调用无参数类型构造函数super（无）。

## 构造代码块：

没有函数头
作用：给对象初始化，在对象建立时候运行，在构造函数执行前执行
构造代码块是给所有对象初始化，而构造函数只为 形参匹配的对象初始化

this可以用来当做构造函数使用:

```
this(形参表)//根据形参表的不同，调用不同的重载构造函数
```

## 静态代码块：

优先于对象执行，因为没有名字，所以在类被加载的时候（即该类进入内存的时候调用，如果已经进入内存，则不会二次调用）被隐式调用

如果类中有多个静态代码块，执行顺序为函数在类中的从上到下的顺序执行

```
static {

//代码块体

  }
```

