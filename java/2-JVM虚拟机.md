# Java内存区域：

线程共享区域：方法区，堆
线程私有区域：本地方法栈，程序计数器，本地方法栈

## 堆

数组与对象在此区域分配内存。
数组是特殊的对象。

对象包含：

- 对象头

- 实例数据

- 填充数据

  

数组是特殊的对象，在对象头会有一个额外的一个字段用于存储数组的长度。

## 方法区栈帧

类 类型信息：

- 当前类全限定名，直接父类的全限定名，直接接口的全限定名
- 类修饰符
- 实例字段描述信息（）：字段名字，类型，修饰符（权限，final，volatile），字段实际所需内存在堆中分配。
- 方法信息：方法名 返回值 参数表 修饰符（权限，static？，synchornized），以及方法执行字节码（方法体).
- 静态字段信息：
  non-final静态字段信息：字段内容存储在类信息中（在方法区中开辟内存）。
  final静态字段信息：final static 修饰的变量，其实就像是一个全局访问的变量。他不仅存储在常量池中，还存储在任意一个使用到他的类中。
  假想的例如：

```s
class Hong{
       public final static int m=1;
 }
class Ming{
        Private int n=Hong.m;
} 
```

如果实例化B类，此时final static int m 就被存储在Ming对象的实例数据里了，也就是在堆内存中。           

- 持有加载该类的类加载的引用
- 持有该类的class对象的引用
- 方法表（用于快速的访问到方法，提高效率）

​            
​            

## 虚拟机栈：         

前导概念：
    栈帧：栈帧为一种数据结构，其中存储了方法执行的环境信息，包含：

- 局部变量表
- 操作数栈
- 动态链接
- 返回地址

附应用举例：（以后来补，加一个超链接跳到指定位置，指定位置再添加一个返回链接）

本地方法栈中存储的就是栈帧，栈帧的入栈与出栈，对应方法的调用与结束。

## 本地方法栈

作用类似于虚拟机栈，但是此处存储的栈帧所属于native方法。

## 程序计数器

当中存储了下一条字节码指令的地址。

其用于控制字节码解释器的解释顺序，程序流程控制就是通过程序计数器实现。
    
# 内存分配
什么东西分配到什么区域

# 垃圾回收
垃圾回收的在哪个区域进行？
    堆和方法区
    
何时垃圾回收？
    空间不够
垃圾回收时，有什么条件？
    各个线程处于安全点或者安全区域
        （引用关系不会改变的点或者代码段区域）
垃圾回收的种类，以及各自 特点？
    minor gc
    full gc 
## 算法
标记清除算法
    如何标记？
        引用计数法
            如何确定引用关系存在
                GC ROOTS：
*                     类静态变量
*                     方法参数表
*                     常量？
*                      jni（本地方法）的参数表
                几种引用类型：
*                      强引用
*                      弱应用
*                      软引用
*                     虚引用
    缺点：清理后导致内存碎片化严重
复制算法
标记整理算法
分代垃圾收集
## 垃圾收集器
根据不同区域采用不同特点的收集器

    







# Java内存模型

这是逻辑模型。没有实际硬件区域对应。

## 主内存

## 直接内存

# 字节码文件

初步了解：

mark一下，以后再深入学习，

强化一下，JVM知识。
字节码文件是平台无关性的基石。

字节码文件中只有两种数据类型，无符号数 和 表（一种复合数据类型）。

字节码文件包含：

* 魔数

* 整个类的常量池 constant pool

* 类名以及修饰符
   直接父类
   直接父接口表
   
* 字段名以及描述符，属性表
   以一个字节来保存他的 字段修饰符

* 方法名以及描述符，属性表
   以一个字节来保存他的 方法描述符
   属性表：如Code 属性 方法体中的字节码指令
   局部变量表
   操作数栈
   
   。。。。。。。。等等

![avap](H:\GitRepository\Notes\java\img\javap.png)

解释：

flags：方法修饰符标志



stack=2，操作数栈深度为2。深度由编译器时确定。

locals=2，本地变量表长度为2，索引从0开始！长度编译器决定，		包含方法参数，以及方法内局部变量。

args_size，方法参数大小



命令解释：

iconst_1: intContstant 1:定义int类型的常量1放入操作数栈中。

istore_1:将栈顶的int类型的数据存入 到 索引为1的局部变量表中。

iload_1: 将局部变量表中索引为1的int型数据加载到栈顶。

iadd: 将操作数栈中的两个int型元素依次弹出，再进行加法，最后		   将结果推入栈中。

i2b: int to byte: int类型转byte类型





字节码常量池：（该常量池在类加载的时候，被加载放入运行时常量池）

- 字面量，final修饰的常量，以及字符串字面量

- 符号引用
  类的全限定名（有没有直接父类和接口的全限定名？）
  字段的名字以及描述符
  方法的名字以及描述符

  ​     