# Java内存区域：

线程共享区域：方法区，堆
线程私有区域：本地方法栈，程序计数器，本地方法栈

## 堆

数组与对象在此区域分配内存。
数组是特殊的对象。

对象包含：

- 对象头

- 实例数据

- 填充数据

  

数组是特殊的对象，在对象头会有一个额外的一个字段用于存储数组的长度。

## 方法区栈帧

类 类型信息：

- 当前类全限定名，直接父类的全限定名，直接接口的全限定名
- 类修饰符
- 实例字段描述信息（）：字段名字，类型，修饰符（权限，final，volatile），字段实际所需内存在堆中分配。
- 方法信息：方法名 返回值 参数表 修饰符（权限，static？，synchornized），以及方法执行字节码（方法体).
- 静态字段信息：
  non-final静态字段信息：字段内容存储在类信息中（在方法区中开辟内存）。
  final静态字段信息：final static 修饰的变量，其实就像是一个全局访问的变量。他不仅存储在常量池中，还存储在任意一个使用到他的类中。
  假想的例如：

```s
class Hong{
       public final static int m=1;
 }
class Ming{
        Private int n=Hong.m;
} 
```

如果实例化B类，此时final static int m 就被存储在Ming对象的实例数据里了，也就是在堆内存中。           

- 持有加载该类的类加载的引用
- 持有该类的class对象的引用
- 方法表（用于快速的访问到方法，提高效率）

​            
​            

## 虚拟机栈：         

前导概念：
    栈帧：栈帧为一种数据结构，其中存储了方法执行的环境信息，包含：

- 局部变量表
- 操作数栈
- 动态链接
- 返回地址

附应用举例：（以后来补，加一个超链接跳到指定位置，指定位置再添加一个返回链接）

本地方法栈中存储的就是栈帧，栈帧的入栈与出栈，对应方法的调用与结束。

## 本地方法栈

作用类似于虚拟机栈，但是此处存储的栈帧所属于native方法。

## 程序计数器

当中存储了下一条字节码指令的地址。

其用于控制字节码解释器的解释顺序，程序流程控制就是通过程序计数器实现。
    

# Java内存模型

这是逻辑模型。没有实际硬件区域对应。

## 主内存

## 直接内存

# 字节码文件

初步了解：

mark一下，以后再深入学习，

强化一下，JVM知识。

![avap](H:\GitRepository\Notes\java\img\javap.png)

解释：

flags：方法修饰符标志



stack=2，操作数栈深度为2。深度由编译器时确定。

locals=2，本地变量表长度为2，索引从0开始！长度编译器决定，		包含方法参数，以及方法内局部变量。

args_size，方法参数大小



命令解释：

iconst_1: intContstant 1:定义int类型的常量1放入操作数栈中。

istore_1:将栈顶的int类型的数据存入 到 索引为1的局部变量表中。

iload_1: 将局部变量表中索引为1的int型数据加载到栈顶。

iadd: 将操作数栈中的两个int型元素依次弹出，再进行加法，最后		   将结果推入栈中。

i2b: int to byte: int类型转byte类型





字节码常量池：（该常量池在类加载的时候，被加载放入运行时常量池）

- 字面量，final修饰的常量，以及字符串字面量

- 符号引用
  类的全限定名（有没有直接父类和接口的全限定名？）
  字段的名字以及描述符
  方法的名字以及描述符

  ​     